<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LA‚ù§Ô∏èSERENA - Arquitecto 2.0</title>
    
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><rect width=%22100%22 height=%22100%22 fill=%22red%22/><text x=%2250%%22 y=%2255%%22 font-family=%22Arial%22 font-weight=%22bold%22 font-size=%2260%22 fill=%22white%22 text-anchor=%22middle%22 dominant-baseline=%22middle%22>LS</text></svg>">

    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
    
    <style>
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background-color: #87CEEB; font-family: 'Segoe UI', sans-serif; }
        #renderCanvas { width: 100vw; height: 100vh; display: block; outline: none; }
        
        /* PANEL DE ARQUITECTO 2.0 */
        #panel-arquitecto {
            position: absolute; top: 20px; right: 20px; width: 280px;
            background: rgba(10, 10, 20, 0.95); color: white; padding: 20px;
            border-radius: 12px; border: 2px solid #00d2ff; box-shadow: 0 10px 30px rgba(0,0,0,0.8);
            z-index: 200;
        }
        #panel-arquitecto h3 { margin: 0 0 15px 0; font-size: 16px; color: #00d2ff; text-align: center; text-transform: uppercase; }
        
        .selector-container { margin-bottom: 20px; text-align: center; }
        select { padding: 8px; width: 100%; background: #333; color: white; border: 1px solid #555; border-radius: 5px; font-size: 14px; }
        
        .control-group { margin-bottom: 15px; }
        .control-group label { display: flex; justify-content: space-between; font-size: 12px; margin-bottom: 5px; color: #ccc; }
        input[type=range] { width: 100%; cursor: pointer; accent-color: #00d2ff; }
        .valor-display { color: #00ff00; font-family: monospace; font-weight: bold; }
        
        #toolbar { position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%); display: flex; gap: 15px; z-index: 100; }
        .btn { background: #ffd700; color: #000; border: none; padding: 10px 20px; border-radius: 30px; font-weight: bold; cursor: pointer; }
        .btn-rescate { background: #ff4444; color: white; }
    </style>
</head>
<body>

    <div id="panel-arquitecto">
        <h3>üèóÔ∏è Arquitecto 2.0</h3>
        
        <div class="selector-container">
            <label style="font-size:12px; color:#aaa;">Selecciona edificio a editar:</label>
            <select id="edificioSelector" onchange="cambiarSeleccion()">
                <option value="muni">üè¢ Municipalidad</option>
                <option value="intendencia">üèõÔ∏è Intendencia</option>
            </select>
        </div>
        
        <hr style="border-color: #444; margin-bottom: 15px;">

        <div class="control-group">
            <label>Posici√≥n X <span id="valX" class="valor-display">0</span></label>
            <input type="range" id="inputX" min="-1500" max="1500" step="1">
        </div>

        <div class="control-group">
            <label>Posici√≥n Z <span id="valZ" class="valor-display">0</span></label>
            <input type="range" id="inputZ" min="-1500" max="1500" step="1">
        </div>

        <div class="control-group">
            <label>Rotaci√≥n <span id="valRot" class="valor-display">0¬∞</span></label>
            <input type="range" id="inputRot" min="0" max="360" step="1">
        </div>
        
        <div style="font-size:11px; color:#aaa; margin-top:10px; line-height:1.4;">
            üí° Si al rotar el edificio se desplaza lejos, usa X y Z para traerlo de vuelta.
        </div>
    </div>

    <div id="toolbar">
        <button class="btn" onclick="camaraAerea()">üöÅ Vista A√©rea</button>
        <button class="btn btn-rescate" onclick="location.reload()">üîÑ Reiniciar</button>
    </div>

    <canvas id="renderCanvas"></canvas>

    <script>
        const canvas = document.getElementById("renderCanvas");
        const engine = new BABYLON.Engine(canvas, true);

        // --- BASE DE DATOS DE COORDENADAS ---
        // Aqu√≠ guardamos los datos temporalmente
        let dbEdificios = {
            muni: { mesh: null, x: 757, z: 187, rot: 180, scale: 240, file: "municipalidad.glb" },
            intendencia: { mesh: null, x: 200, z: -600, rot: 0, scale: 200, file: "intendencia.glb" } 
            // Puse coordenadas iniciales aproximadas para la intendencia (esquina opuesta)
        };

        let edificioActual = "muni"; // Cu√°l estamos editando ahora
        let scene, camera, shadowGenerator;

        const crearEscena = function () {
            scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color3(0.5, 0.7, 0.9);
            
            const hemi = new BABYLON.HemisphericLight("hemi", new BABYLON.Vector3(0, 1, 0), scene);
            hemi.intensity = 0.6;
            
            const dir = new BABYLON.DirectionalLight("dir", new BABYLON.Vector3(-1, -2, -1), scene);
            dir.position = new BABYLON.Vector3(200, 400, 200);
            
            shadowGenerator = new BABYLON.ShadowGenerator(2048, dir);
            
            camera = new BABYLON.ArcRotateCamera("cam", 0, Math.PI/3, 800, new BABYLON.Vector3(500, 0, 0), scene);
            camera.attachControl(canvas, true);
            
            return scene;
        };

        scene = crearEscena();

        // 1. CARGAR MAPA
        const suelo = BABYLON.MeshBuilder.CreateGround("suelo", {width: 3000, height: 3000}, scene);
        const matSuelo = new BABYLON.StandardMaterial("matSuelo", scene);
        matSuelo.diffuseTexture = new BABYLON.Texture("mapa.jpg", scene);
        matSuelo.specularColor = new BABYLON.Color3(0,0,0);
        suelo.material = matSuelo;
        suelo.receiveShadows = true;

        // 2. FUNCI√ìN PARA CARGAR EDIFICIOS
        function cargarEdificio(clave) {
            let datos = dbEdificios[clave];
            
            BABYLON.SceneLoader.ImportMesh("", "./", datos.file, scene, function (meshes) {
                let mesh = meshes[0];
                datos.mesh = mesh; // Guardamos la referencia
                
                // Normalizar escala
                const bound = mesh.getHierarchyBoundingVectors(true);
                const size = bound.max.subtract(bound.min);
                const factor = datos.scale / Math.max(size.x, size.y, size.z);
                mesh.scaling = new BABYLON.Vector3(factor, factor, factor);
                
                // Aplicar posici√≥n inicial de la DB
                actualizarMeshDesdeDB(clave);
                
                // Sombras
                meshes.forEach(m => {
                    shadowGenerator.addShadowCaster(m);
                    m.receiveShadows = true;
                });
                
                // Si es el que estamos editando, actualizar sliders
                if (clave === edificioActual) actualizarSlidersDesdeDB();
            }, function() {
                // Si falla (ej: no existe intendencia.glb)
                console.log("No se encontr√≥ " + datos.file);
            });
        }

        // Cargamos ambos
        cargarEdificio("muni");
        cargarEdificio("intendencia");

        // 3. L√ìGICA DEL PANEL
        const inputX = document.getElementById("inputX");
        const inputZ = document.getElementById("inputZ");
        const inputRot = document.getElementById("inputRot");
        const valX = document.getElementById("valX");
        const valZ = document.getElementById("valZ");
        const valRot = document.getElementById("valRot");

        // A) Cuando movemos un slider -> Actualiza el 3D y la DB
        function onSliderChange() {
            let datos = dbEdificios[edificioActual];
            if (!datos.mesh) return;

            // Leer valores
            datos.x = parseFloat(inputX.value);
            datos.z = parseFloat(inputZ.value);
            datos.rot = parseFloat(inputRot.value);

            // Actualizar textos
            valX.innerText = datos.x;
            valZ.innerText = datos.z;
            valRot.innerText = datos.rot + "¬∞";

            // Aplicar al 3D
            datos.mesh.position.x = datos.x;
            datos.mesh.position.z = datos.z;
            datos.mesh.rotation.y = datos.rot * (Math.PI / 180);
        }

        // B) Cuando cambiamos de edificio -> Actualiza los sliders
        window.cambiarSeleccion = function() {
            let select = document.getElementById("edificioSelector");
            edificioActual = select.value;
            actualizarSlidersDesdeDB();
            
            // Enfocar c√°mara en el nuevo edificio seleccionado
            let datos = dbEdificios[edificioActual];
            if(datos.mesh) {
                camera.setTarget(datos.mesh.position);
            }
        }

        function actualizarSlidersDesdeDB() {
            let datos = dbEdificios[edificioActual];
            inputX.value = datos.x;
            inputZ.value = datos.z;
            inputRot.value = datos.rot;
            
            valX.innerText = datos.x;
            valZ.innerText = datos.z;
            valRot.innerText = datos.rot + "¬∞";
        }

        function actualizarMeshDesdeDB(clave) {
            let datos = dbEdificios[clave];
            if(datos.mesh) {
                datos.mesh.position.x = datos.x;
                datos.mesh.position.z = datos.z;
                datos.mesh.rotation.y = datos.rot * (Math.PI / 180);
            }
        }

        inputX.addEventListener("input", onSliderChange);
        inputZ.addEventListener("input", onSliderChange);
        inputRot.addEventListener("input", onSliderChange);

        window.camaraAerea = function() {
            camera.setTarget(new BABYLON.Vector3(500, 0, 200));
            camera.radius = 1200;
        }

        engine.runRenderLoop(() => { scene.render(); });
        window.addEventListener("resize", () => { engine.resize(); });
    </script>
</body>
</html>
