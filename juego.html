<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DiagnÃ³stico La Serena</title>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
    <style>
        body, html { margin:0; padding:0; overflow:hidden; background:#87CEEB; font-family:sans-serif; }
        #renderCanvas { width: 100%; height: 100%; }
        
        /* CONSOLA DE DIAGNÃ“STICO */
        #debug-log {
            position: absolute; top: 10px; left: 10px;
            width: 300px; height: 200px;
            background: rgba(0,0,0,0.8); color: #00ff00;
            font-family: monospace; font-size: 12px;
            padding: 10px; overflow-y: auto; z-index: 1000;
            border: 2px solid #00ff00; pointer-events: none;
        }

        /* PANEL DE CALIBRACIÃ“N */
        #panel-calibracion {
            position: absolute; top: 10px; right: 10px; width: 250px;
            background: rgba(20,20,30,0.9); color: white; padding: 15px;
            border: 1px solid white; z-index: 200;
        }
        input[type=range] { width: 100%; }
    </style>
</head>
<body>

    <div id="debug-log">INICIANDO SISTEMA...<br></div>

    <div id="panel-calibracion">
        <h3>ðŸ”§ MODO REPARACIÃ“N</h3>
        <select id="selector" onchange="cambiarEdificio()">
            <option value="muni">MUNICIPALIDAD</option>
            <option value="intendencia">INTENDENCIA</option>
        </select>
        <p>RotaciÃ³n: <input type="range" id="rot" min="0" max="360" value="0" oninput="ajustar()"></p>
        <p>TamaÃ±o: <input type="range" id="scale" min="0.1" max="5" step="0.1" value="1" oninput="ajustar()"></p>
        <p>Pos X: <input type="range" id="posX" min="-1000" max="1000" value="0" oninput="ajustar()"></p>
        <p>Pos Z: <input type="range" id="posZ" min="-1000" max="1000" value="0" oninput="ajustar()"></p>
    </div>

    <canvas id="renderCanvas"></canvas>

    <script>
        // --- LOGGER EN PANTALLA ---
        function log(msg, error=false) {
            const el = document.getElementById("debug-log");
            el.innerHTML += (error ? "<span style='color:red'>âœ– " : "âœ” ") + msg + (error ? "</span>" : "") + "<br>";
            console.log(msg);
        }

        const canvas = document.getElementById("renderCanvas");
        const engine = new BABYLON.Engine(canvas, true);
        
        // DATOS
        let edificios = {
            muni: { mesh: null, file: "municipalidad.glb", x: 757, z: 187, rot: 180, scale: 1 },
            intendencia: { mesh: null, file: "intendencia.glb", x: 455, z: 386, rot: 0, scale: 1 }
        };
        let activeKey = "muni";

        const crearEscena = function () {
            const scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color3(0.5, 0.7, 1.0); // Azul cielo

            // CÃMARA FIJA (NO DEPENDE DE NADA)
            const camera = new BABYLON.ArcRotateCamera("cam", -Math.PI/2, Math.PI/3, 800, BABYLON.Vector3.Zero(), scene);
            camera.attachControl(canvas, true);
            camera.minZ = 1;      // Ver cosas cerca
            camera.maxZ = 5000;   // Ver cosas lejos

            // LUZ
            new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);

            // 1. EL SUELO (SEGURIDAD)
            const suelo = BABYLON.MeshBuilder.CreateGround("suelo", {width: 2500, height: 2500}, scene);
            const matSuelo = new BABYLON.StandardMaterial("matSuelo", scene);
            const tex = new BABYLON.Texture("mapa.jpg", scene, 
                null, null, null, 
                () => log("Mapa cargado OK"), 
                () => {
                    log("ERROR: mapa.jpg no encontrado", true);
                    matSuelo.diffuseColor = new BABYLON.Color3(0, 1, 0); // Verde si falla
                }
            );
            matSuelo.diffuseTexture = tex;
            matSuelo.backFaceCulling = false; // Ver por ambos lados
            suelo.material = matSuelo;

            return scene;
        };

        const scene = crearEscena();

        // CARGADOR ROBUSTO
        function cargarModelo(key) {
            log("Buscando: " + edificios[key].file + "...");
            
            BABYLON.SceneLoader.ImportMesh("", "./", edificios[key].file, scene, 
                function (meshes) {
                    log("CARGADO: " + edificios[key].file);
                    let m = meshes[0];
                    edificios[key].mesh = m;
                    
                    // Asegurar que se ve (Normalizar tamaÃ±o)
                    const bounds = m.getHierarchyBoundingVectors(true);
                    const size = bounds.max.subtract(bounds.min);
                    const maxDim = Math.max(size.x, size.y, size.z);
                    const factor = 150 / maxDim; // Forzar tamaÃ±o visible (150 unidades)
                    
                    m.scaling = new BABYLON.Vector3(factor, factor, factor);
                    m.position = new BABYLON.Vector3(edificios[key].x, 0, edificios[key].z);
                    
                    if (key === activeKey) actualizarUI();

                }, 
                null, 
                function (scene, message) {
                    log("FALLO: " + edificios[key].file, true);
                    // Crear CAJA ROJA DE EMERGENCIA
                    let caja = BABYLON.MeshBuilder.CreateBox(key + "_fail", {size: 50}, scene);
                    caja.position = new BABYLON.Vector3(edificios[key].x, 25, edificios[key].z);
                    let mat = new BABYLON.StandardMaterial("error", scene);
                    mat.diffuseColor = new BABYLON.Color3(1, 0, 0);
                    caja.material = mat;
                    edificios[key].mesh = caja;
                    log("--> Se creÃ³ una caja roja en su lugar.");
                }
            );
        }

        cargarModelo("muni");
        cargarModelo("intendencia");

        // --- CONTROLES UI ---
        const uiRot = document.getElementById("rot");
        const uiScale = document.getElementById("scale");
        const uiX = document.getElementById("posX");
        const uiZ = document.getElementById("posZ");

        window.ajustar = function() {
            let data = edificios[activeKey];
            if (!data.mesh) return;

            // Leer UI
            data.rot = parseFloat(uiRot.value);
            let escalaUsuario = parseFloat(uiScale.value);
            data.x = parseFloat(uiX.value);
            data.z = parseFloat(uiZ.value);

            // Aplicar
            data.mesh.rotation.y = data.rot * (Math.PI/180);
            data.mesh.position.x = data.x;
            data.mesh.position.z = data.z;

            // Mantenemos la escala base calculada al cargar * escala usuario
            // (Truco para no perder la referencia del tamaÃ±o original)
            if(data.mesh.name.indexOf("_fail") === -1) { // Si no es la caja de error
                 // Recalculamos basÃ¡ndonos en escala 1 visual
                 // (SimplificaciÃ³n para este modo debug)
                 const currentScale = data.mesh.scaling.clone(); 
                 // Solo aplicamos cambio relativo si es necesario, pero 
                 // para simplificar en debug:
                 // data.mesh.scaling = new BABYLON.Vector3(escalaUsuario, escalaUsuario, escalaUsuario); 
                 // OJO: Esto puede hacerlos minÃºsculos de nuevo.
                 // Mejor solo mover y rotar por ahora en modo rescate.
            }
        }

        window.cambiarEdificio = function() {
            activeKey = document.getElementById("selector").value;
            actualizarUI();
        }

        function actualizarUI() {
            let data = edificios[activeKey];
            uiRot.value = data.rot;
            uiX.value = data.x;
            uiZ.value = data.z;
            // Enfocar cÃ¡mara
            if(data.mesh) {
                scene.activeCamera.setTarget(data.mesh.position);
            }
        }

        engine.runRenderLoop(() => scene.render());
        window.addEventListener("resize", () => engine.resize());
    </script>
</body>
</html>
